'''
    Tree data structure is actually a subtree that holds each state's board, evaluation, depth in the main tree and children(These children are also trees).
    It is during the creation of the tree that the program checks for timelimit too.
    
    Static evaluation function:
    
    If the tree is cut due to time limit, then leaves are evaluated using this static function-->
    In this implementation we evaluate tree at odd depth's(max's play only)
    For Max, the lines with even number of empty blocks are favourable whereas lines with odd number of empty blocks are unfavourable
    Even number of empty blocks means that it will probably have a empty block left in one of it's future turns even if min uses one of the such lines
    On the other hand, Odd number of empty blocks in a line are dangerous as max maybe forced to complete the line in future moves
    
    Hence static evalution function is (Count of lines with even empty blocks - count of line with odd empty blocks)
    
    If tree reaches gameover board-->
    Then in case of max's win: static function is 1000
    Else in case of max'x loss:
    Static function is set to a very low value
    Moreover, not all losses are equal. If by optimal play evaltion max seems to lose whatever move it made, max should choose the move that  delays the loss, and wait for other player to make a mistake
    Hence for loss static function= -1000+depth at which loss ocuurs


    Minimax algorithm:
    Minimax algorithm is used simultaneously with creation of tree. As this implementation of tree is depth first, the minimax algorithm is coupled with the tree creation.
    
    Depth cuttoff for timelimit:
    Instead of fixing a determining the depth at which to cut of the search tree, we instead use iterative deepening.
    As per this method we increase the search tree's depth by two each time.
    We assign a large part of timelimit to searching and save a very small portion of time to display latest result.
    If the time for searching is exceeded, we stop searching and display the result that was generated by the previous search smaller depth.
    In case the entire tree gets traversed without cut off, we display the result directly.
    '''

import copy
import time
import sys

__author__ = 'tejashree'


class MyError(Exception):
    pass

'''used tree data structure to store next boards. Each board is stored as tree where b stores current board and list childtrees stores all its next possible boards'''
class Tree:
    def __init__(self, number, time, board,depth):
        global maxd,n1,timeout,fulltree
        self.n = number
        self.t = time
        self.b = board
        self.d=depth
        self.childtrees=[]
        if self.timecrsossed():
            raise MyError()

        if depth<maxd and not self.gameover():

            self.childtrees=self.children()
        '''generates evalution at current node, this function applies minimax for intermideate nodes and static function for leaf'''
        self.sf=self.staticfunc()

    def next(self): #selects best option from immediate successors
        succ=[x.sf for x in self.childtrees]
        maxsucc=max(succ)
        h=succ.index(maxsucc)
        nextmove=''
        for i in self.childtrees[h].b:
            for j in i:
                nextmove+=j
        return nextmove
    def staticfunc(self): #this evaluates all boards generated from the input
        global fulltree
        if self.gameover(): #Gameover indicates win or loss

            if self.d%2==0: #even--->min's move--> board state after max's move inotherwords, max loses. In case of loss state gets very low value
                '''Moreover, not all losses are equal. If by optimal play evaltion max seems to lose whatever move it made, max should choose the move that atleast delays the loss, and wait for other player to make a mistake'''
                s=-1000+self.d#if max is losing, static function is very low number(1000) plus depth, hence it will choose the longest path to defeat
            else:
                s=1000# if max wins board state gets assigned value +1000
        else:
            if self.d<maxd:# evaluates intermideate nodes hence search tree is cut we apply minimax algorithm here

                if self.d%2==0: #even---min's move
                    s1=[x.sf for x in self.childtrees]
                    s= min(s1)

                else: #odd ---- max's move
                    s1=[x.sf for x in self.childtrees]
                    s=max(s1)
            else:
                ''' If the tree is cut due to time limit, then leaves are evaluated using this static function,
                    In this implementation we evaluate tree at odd depth's(max's play only)
                    For Max, the lines with even number of empty blocks are favourable whereas lines with odd number of empty blocks are unfavourable
                    Even number of empty blocks means that it will probably have a empty block left in one of it's future turns even if min uses one of the such lines
                    On the other hand, Odd number of empty blocks in a line are dangerous as max maybe forced to complete the line in future moves
                    
                    Hence static evalution function is (Count of lines with even empty blocks - count of line with odd empty blocks)
                    '''
                func=0
                fulltree=False
                for i in self.b:#checks rows for number of empty blocks
                    k=i.count('.')
                    if k%2==0:
                        func+=1
                    else:
                        func-=1
                for i in range (0,self.n): #checks columns for number of empty blocks

                    j =[x[i] for x in self.b]
                    k=j.count('.')
                    if k%2==0:
                        func+=1
                    else:
                        func-=1

                j=[self.b[x][x] for x in range(0,self.n)] #checks diagonal
                k=j.count('.')
                if k%2==0:
                        func+=1
                else:
                        func-=1

                j=[self.b[x][self.n-1-x] for x in range(0,self.n)] #checks diagonal
                k=j.count('.')
                if k%2==0:
                        func+=1
                else:
                        func-=1
                s=func
        return s
    def timecrsossed(self):
        if time.time()>timeout:
            return True
        else:
            return False
    def gameover(self):
        # if full row complete then return true
        for i in self.b:
            if '.' not in i:
                return True
        # if coulmn full then return true
        for i in range (0,self.n):

            j =[x[i] for x in self.b]
            if '.' not in j:
                return True
        # if diagonal 1 full then return true
        j=[self.b[x][x] for x in range(0,self.n)]

        if '.' not in j:
            return True
        # if diagonal 2 full then return true
        j=[self.b[x][self.n-1-x] for x in range(0,self.n)]
        if '.' not in j:
            return True
        return False

    def children(self):
        c=[]
        for i in range (0,self.n):
            for j in range (0,self.n):
                k=copy.deepcopy(self.b)
                if k[i][j]=='.':
                    k[i][j]='x'
                    m=Tree(n1,t,k,self.d+1)
                    c.append(m)
        return c

if __name__ == "__main__":
    f=[]
    for arg in sys.argv:
        f.append(arg)
    n1=int(f[1]) #accepts n from user
    b=f[2] #accepts board configuration from user
    t=float(f[3]) #accepts time limit from user
    #decides how much maximum time used for searching
    if 0.1*t<0.5:

        t=0.9*t
    else:
        t=t-0.5
    timeout = time.time() + t #program stops creating new trees on reaching this point in time

    fulltree=False #boolean fulltree will tell when to stop search because the entire tree is being traversed
    maxd=3
    print "Generating next board state......."
    #instead of predefining the depth to where we should cutoff tree, Iterative deepening is used
    while timeout>time.time() and not fulltree:

        fulltree=True
        a=[]
        for i in range(0,n1):
            r=[]
            for j in range (0,n1):
                s=b[i*n1+j]
                r.append(s)
            a.append(r)
        try:
            n=Tree(n1,t,a,1)#will throw error when time limit is exceeded
            if not n.gameover():
                final=n.next()
            else:
                print "Game already over!!"
            maxd=maxd+2 #depth incresed by two for next iteration
        except MyError as e:
            pass # catches error thrown by Tree when timelimit is exceeded
    print "Time taken", time.time()-timeout+t
    print final

